#!/usr/bin/env bash
#
# sandbox - Docker sandbox for AI coding agents on Linux
#
# Replicates Docker Desktop's sandbox feature for plain Docker on Linux.
# Creates isolated containers per workspace with mounted configs.
#
# Usage:
#   sandbox run [options] <agent>    Run an agent in a sandbox
#   sandbox ls                       List all sandboxes
#   sandbox rm <sandbox-id|name>     Remove a sandbox
#   sandbox inspect <sandbox-id>     Show sandbox details
#   sandbox exec <sandbox-id> <cmd>  Execute command in sandbox
#   sandbox stop <sandbox-id>        Stop a running sandbox
#   sandbox start <sandbox-id>       Start a stopped sandbox
#
# Examples:
#   sandbox run claude
#   sandbox run -e API_KEY=xxx -v ~/data:/data claude
#   sandbox run --mount-docker-socket claude
#   sandbox ls
#   sandbox rm myproject-claude
#

set -euo pipefail

# Configuration
SANDBOX_LABEL="ai.sandbox=true"
SANDBOX_DATA_VOLUME_PREFIX="sandbox-data"
DEFAULT_IMAGE="ubuntu:24.04"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Agent configurations
declare -A AGENT_IMAGES=(
    ["claude"]="docker/sandbox-templates:claude-code"
    ["opencode"]="ghcr.io/anomalyco/opencode:latest"
    ["aider"]="paulgauthier/aider"
    ["default"]="ubuntu:24.04"
)

declare -A AGENT_COMMANDS=(
    ["claude"]="claude"
    ["opencode"]="opencode"
    ["aider"]="aider"
    ["default"]="/bin/bash"
)

# Default arguments for each agent (use . for current directory where needed)
declare -A AGENT_DEFAULT_ARGS=(
    ["claude"]=""
    ["opencode"]="."
    ["aider"]=""
    ["default"]=""
)

# Home directory config paths to mount (read-only by default)
HOME_CONFIG_PATHS=(
    ".claude"
    ".anthropic"
    ".config/claude"
    ".opencode"
    ".aider"
    ".config/opencode"
)

# Home directory config paths to mount read-write
HOME_CONFIG_PATHS_RW=(
    ".claude"
    ".anthropic"
    ".opencode"
)

#
# Utility functions
#

log_info() {
    echo -e "${BLUE}[INFO]${NC} $*"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

die() {
    log_error "$*"
    exit 1
}

# Generate a sandbox name from workspace path and agent
generate_sandbox_name() {
    local workspace="$1"
    local agent="$2"
    # Use last directory component + agent name
    local dir_name
    dir_name=$(basename "$workspace")
    # Sanitize for docker naming
    dir_name=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_.-]/-/g')
    echo "sandbox-${dir_name}-${agent}"
}

# Generate workspace hash for unique identification
generate_workspace_hash() {
    local workspace="$1"
    echo -n "$workspace" | sha256sum | cut -c1-12
}

# Find existing sandbox for workspace/agent combination
find_sandbox() {
    local workspace="$1"
    local agent="$2"
    local workspace_hash
    workspace_hash=$(generate_workspace_hash "$workspace")
    
    docker ps -a --filter "label=${SANDBOX_LABEL}" \
        --filter "label=ai.sandbox.workspace_hash=${workspace_hash}" \
        --filter "label=ai.sandbox.agent=${agent}" \
        --format "{{.ID}}" | head -1
}

# Get git user config
get_git_user_name() {
    git config --global user.name 2>/dev/null || echo ""
}

get_git_user_email() {
    git config --global user.email 2>/dev/null || echo ""
}

#
# Commands
#

cmd_run() {
    local agent=""
    local workspace="$PWD"
    local env_vars=()
    local volumes=()
    local mount_docker_socket=false
    local template=""
    local detach=false
    local force_recreate=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -e|--env)
                env_vars+=("$2")
                shift 2
                ;;
            -v|--volume)
                volumes+=("$2")
                shift 2
                ;;
            --mount-docker-socket)
                mount_docker_socket=true
                shift
                ;;
            --template)
                template="$2"
                shift 2
                ;;
            -w|--workspace)
                workspace="$2"
                shift 2
                ;;
            -d|--detach)
                detach=true
                shift
                ;;
            --force-recreate)
                force_recreate=true
                shift
                ;;
            -h|--help)
                show_run_help
                exit 0
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                agent="$1"
                shift
                break
                ;;
        esac
    done
    
    # Validate agent
    if [[ -z "$agent" ]]; then
        die "Agent name required. Usage: sandbox run [options] <agent>"
    fi
    
    # Resolve workspace to absolute path
    workspace=$(cd "$workspace" && pwd)
    
    # Determine image
    local image
    if [[ -n "$template" ]]; then
        image="$template"
    elif [[ -v AGENT_IMAGES[$agent] ]]; then
        image="${AGENT_IMAGES[$agent]}"
    else
        image="${AGENT_IMAGES[default]}"
        log_warn "Unknown agent '$agent', using default image: $image"
    fi
    
    # Determine command
    local cmd
    if [[ -v AGENT_COMMANDS[$agent] ]]; then
        cmd="${AGENT_COMMANDS[$agent]}"
    else
        cmd="${AGENT_COMMANDS[default]}"
    fi
    
    # Check for existing sandbox
    local existing_sandbox
    existing_sandbox=$(find_sandbox "$workspace" "$agent")
    
    if [[ -n "$existing_sandbox" ]]; then
        if [[ "$force_recreate" == "true" ]]; then
            log_info "Removing existing sandbox: $existing_sandbox"
            docker rm -f "$existing_sandbox" >/dev/null
            existing_sandbox=""
        else
            # Check if running
            local status
            status=$(docker inspect -f '{{.State.Status}}' "$existing_sandbox" 2>/dev/null || echo "unknown")
            
            if [[ "$status" == "running" ]]; then
                log_info "Attaching to existing sandbox: $existing_sandbox"
                docker attach "$existing_sandbox"
                return 0
            elif [[ "$status" == "exited" ]]; then
                log_info "Starting existing sandbox: $existing_sandbox"
                docker start -ai "$existing_sandbox"
                return 0
            else
                log_warn "Sandbox in unexpected state ($status), recreating..."
                docker rm -f "$existing_sandbox" >/dev/null 2>&1 || true
                existing_sandbox=""
            fi
        fi
    fi
    
    # Build docker run arguments
    local run_args=()
    local sandbox_name
    sandbox_name=$(generate_sandbox_name "$workspace" "$agent")
    local workspace_hash
    workspace_hash=$(generate_workspace_hash "$workspace")
    
    run_args+=(--name "$sandbox_name")
    run_args+=(--label "$SANDBOX_LABEL")
    run_args+=(--label "ai.sandbox.workspace=$workspace")
    run_args+=(--label "ai.sandbox.workspace_hash=$workspace_hash")
    run_args+=(--label "ai.sandbox.agent=$agent")
    run_args+=(--label "ai.sandbox.created=$(date -Iseconds)")
    
    # Interactive TTY
    if [[ "$detach" == "false" ]]; then
        run_args+=(-it)
    else
        run_args+=(-d)
    fi
    
    # Mount workspace at same path
    run_args+=(-v "$workspace:$workspace")
    
    # Mount home directory configs
    local home_dir="$HOME"
    for config_path in "${HOME_CONFIG_PATHS[@]}"; do
        local full_path="$home_dir/$config_path"
        if [[ -e "$full_path" ]]; then
            local mount_opts=":ro"
            # Check if should be read-write
            for rw_path in "${HOME_CONFIG_PATHS_RW[@]}"; do
                if [[ "$config_path" == "$rw_path" ]]; then
                    mount_opts=""
                    break
                fi
            done
            run_args+=(-v "$full_path:/root/$config_path$mount_opts")
            log_info "Mounting config: ~/$config_path"
        fi
    done
    
    # Mount SSH keys (read-only)
    if [[ -d "$home_dir/.ssh" ]]; then
        run_args+=(-v "$home_dir/.ssh:/root/.ssh:ro")
        log_info "Mounting SSH keys"
    fi
    
    # Mount git config
    if [[ -f "$home_dir/.gitconfig" ]]; then
        run_args+=(-v "$home_dir/.gitconfig:/root/.gitconfig:ro")
    fi
    
    # Inject git user info
    local git_name git_email
    git_name=$(get_git_user_name)
    git_email=$(get_git_user_email)
    if [[ -n "$git_name" ]]; then
        run_args+=(-e "GIT_AUTHOR_NAME=$git_name")
        run_args+=(-e "GIT_COMMITTER_NAME=$git_name")
    fi
    if [[ -n "$git_email" ]]; then
        run_args+=(-e "GIT_AUTHOR_EMAIL=$git_email")
        run_args+=(-e "GIT_COMMITTER_EMAIL=$git_email")
    fi
    
    # Mount Docker socket if requested
    if [[ "$mount_docker_socket" == "true" ]]; then
        if [[ -S /var/run/docker.sock ]]; then
            run_args+=(-v /var/run/docker.sock:/var/run/docker.sock)
            log_warn "Docker socket mounted - agent has full Docker access"
        else
            log_warn "Docker socket not found at /var/run/docker.sock"
        fi
    fi
    
    # Add user-specified environment variables
    for env_var in "${env_vars[@]}"; do
        run_args+=(-e "$env_var")
    done
    
    # Add user-specified volumes
    for vol in "${volumes[@]}"; do
        run_args+=(-v "$vol")
    done
    
    # Create persistent data volume for agent credentials
    local data_volume="${SANDBOX_DATA_VOLUME_PREFIX}-${agent}"
    if ! docker volume inspect "$data_volume" >/dev/null 2>&1; then
        log_info "Creating data volume: $data_volume"
        docker volume create "$data_volume" >/dev/null
    fi
    run_args+=(-v "$data_volume:/root/.sandbox-data")
    
    # Network access
    run_args+=(--network host)
    
    # Run container
    log_info "Creating sandbox for '$agent' in $workspace"
    log_info "Image: $image"
    
    # Pull image if needed
    if ! docker image inspect "$image" >/dev/null 2>&1; then
        log_info "Pulling image: $image"
        docker pull "$image"
    fi
    
    # Get default arguments for this agent
    local default_args=""
    if [[ -v AGENT_DEFAULT_ARGS[$agent] ]]; then
        default_args="${AGENT_DEFAULT_ARGS[$agent]}"
    fi
    
    # Use shell wrapper to ensure workdir exists and cd into it
    # This matches Docker Desktop sandbox behavior: workspace mounted at same path
    local shell_wrapper="mkdir -p '$workspace' && cd '$workspace' && exec $cmd $default_args"
    
    # Append any additional arguments from user
    for arg in "$@"; do
        shell_wrapper="$shell_wrapper '$arg'"
    done
    
    docker run "${run_args[@]}" "$image" /bin/sh -c "$shell_wrapper"
}

cmd_ls() {
    local format="${1:-table}"
    
    case "$format" in
        -q|--quiet)
            docker ps -a --filter "label=${SANDBOX_LABEL}" --format "{{.ID}}"
            ;;
        *)
            echo "SANDBOX ID    NAME                           AGENT      STATUS     WORKSPACE"
            docker ps -a --filter "label=${SANDBOX_LABEL}" \
                --format "{{.ID}}|{{.Names}}|{{.Label \"ai.sandbox.agent\"}}|{{.Status}}|{{.Label \"ai.sandbox.workspace\"}}" | \
            while IFS='|' read -r id name agent status workspace; do
                # Truncate long paths
                if [[ ${#workspace} -gt 40 ]]; then
                    workspace="...${workspace: -37}"
                fi
                printf "%-13s %-30s %-10s %-10s %s\n" "$id" "$name" "$agent" "${status:0:10}" "$workspace"
            done
            ;;
    esac
}

cmd_rm() {
    local force=false
    local targets=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--force)
                force=true
                shift
                ;;
            *)
                targets+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#targets[@]} -eq 0 ]]; then
        die "Sandbox ID or name required. Usage: sandbox rm [-f] <sandbox-id|name>..."
    fi
    
    for target in "${targets[@]}"; do
        local rm_args=()
        if [[ "$force" == "true" ]]; then
            rm_args+=(-f)
        fi
        
        if docker rm "${rm_args[@]}" "$target" >/dev/null 2>&1; then
            log_success "Removed sandbox: $target"
        else
            log_error "Failed to remove sandbox: $target"
        fi
    done
}

cmd_inspect() {
    local sandbox_id="$1"
    
    if [[ -z "$sandbox_id" ]]; then
        die "Sandbox ID required. Usage: sandbox inspect <sandbox-id>"
    fi
    
    docker inspect "$sandbox_id"
}

cmd_exec() {
    local sandbox_id="$1"
    shift
    
    if [[ -z "$sandbox_id" ]]; then
        die "Sandbox ID required. Usage: sandbox exec <sandbox-id> <command>"
    fi
    
    docker exec -it "$sandbox_id" "$@"
}

cmd_stop() {
    local sandbox_id="$1"
    
    if [[ -z "$sandbox_id" ]]; then
        die "Sandbox ID required. Usage: sandbox stop <sandbox-id>"
    fi
    
    docker stop "$sandbox_id"
    log_success "Stopped sandbox: $sandbox_id"
}

cmd_start() {
    local sandbox_id="$1"
    local attach=true
    
    if [[ "$1" == "-d" ]]; then
        attach=false
        sandbox_id="$2"
    fi
    
    if [[ -z "$sandbox_id" ]]; then
        die "Sandbox ID required. Usage: sandbox start [-d] <sandbox-id>"
    fi
    
    if [[ "$attach" == "true" ]]; then
        docker start -ai "$sandbox_id"
    else
        docker start "$sandbox_id"
        log_success "Started sandbox: $sandbox_id"
    fi
}

cmd_logs() {
    local sandbox_id="$1"
    shift
    
    if [[ -z "$sandbox_id" ]]; then
        die "Sandbox ID required. Usage: sandbox logs <sandbox-id>"
    fi
    
    docker logs "$@" "$sandbox_id"
}

show_help() {
    cat << 'EOF'
sandbox - Docker sandbox for AI coding agents on Linux

USAGE:
    sandbox <command> [options] [arguments]

COMMANDS:
    run         Run an agent in a sandbox
    ls          List all sandboxes
    rm          Remove one or more sandboxes
    inspect     Show detailed sandbox information
    exec        Execute a command in a sandbox
    stop        Stop a running sandbox
    start       Start a stopped sandbox
    logs        View sandbox logs
    help        Show this help message

EXAMPLES:
    # Run Claude Code in current directory
    sandbox run claude

    # Run with custom environment and volumes
    sandbox run -e API_KEY=xxx -v ~/data:/data claude

    # Run with Docker socket access
    sandbox run --mount-docker-socket claude

    # Use custom template image
    sandbox run --template my-custom-image:latest claude

    # List all sandboxes
    sandbox ls

    # Remove a sandbox
    sandbox rm sandbox-myproject-claude

    # Force recreate sandbox
    sandbox run --force-recreate claude

SUPPORTED AGENTS:
    claude      Claude Code (docker/sandbox-templates:claude-code)
    opencode    OpenCode (ghcr.io/opencode-ai/opencode:latest)
    aider       Aider (paulgauthier/aider)

Run 'sandbox <command> --help' for more information on a command.
EOF
}

show_run_help() {
    cat << 'EOF'
sandbox run - Run an agent in a sandbox

USAGE:
    sandbox run [options] <agent> [agent-args...]

OPTIONS:
    -e, --env KEY=VALUE       Set environment variable
    -v, --volume SRC:DST      Mount additional volume
    -w, --workspace PATH      Use specified workspace (default: current directory)
    -d, --detach              Run in background
    --mount-docker-socket     Mount Docker socket into container
    --template IMAGE          Use custom container image
    --force-recreate          Remove existing sandbox and create new one
    -h, --help                Show this help

DESCRIPTION:
    Creates a new sandbox container for the specified agent, or attaches to
    an existing one if a sandbox already exists for this workspace/agent
    combination.

    The workspace directory is mounted at the same path inside the container.
    Agent config directories (~/.claude, ~/.anthropic, etc.) are automatically
    mounted.

    One sandbox per workspace/agent combination is enforced. Running 'sandbox run'
    in the same directory will reuse the existing container.

EXAMPLES:
    # Basic usage
    sandbox run claude

    # With environment variables
    sandbox run -e NODE_ENV=development -e DEBUG=true claude

    # Mount additional directories
    sandbox run -v ~/datasets:/data:ro -v ~/models:/models claude

    # Use custom image
    sandbox run --template my-dev-env:latest claude

    # Run in different workspace
    sandbox run -w ~/projects/myapp claude
EOF
}

#
# Main
#

main() {
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    local cmd="$1"
    shift
    
    case "$cmd" in
        run)
            cmd_run "$@"
            ;;
        ls|list)
            cmd_ls "$@"
            ;;
        rm|remove)
            cmd_rm "$@"
            ;;
        inspect)
            cmd_inspect "$@"
            ;;
        exec)
            cmd_exec "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        start)
            cmd_start "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            die "Unknown command: $cmd. Run 'sandbox help' for usage."
            ;;
    esac
}

main "$@"
